<?php
  namespace ShiftCodesTK\Forms\FormCore\Properties;
  use ShiftCodesTK\Strings,
      ShiftCodesTK\Validations;

  /** The `HTMLManager` is responsible for the *Classes* and *Attributes* that are to be applied to the element. */
  trait HTMLManager {
    /** @var array The *Classes* and *Attributes* that are to be applied to the element. */
    protected $html = [
      'classes'    => [],  
      'attributes' => []
    ];

    /** Add a *Class* to the Form or Form Child.
     * 
     * - For both the `$class_name` and `$condition`, a `callable` function handler may be provided. Regarding the handler:
     * - - The handler will be invoked whenever the *Class List* is retrieved via `get_classes()`.
     * - - If the handler does not return a value of the correct type, an `UnexpectedValueException` will be thrown when the *Class List* is later retrieved.
     * 
     * @param string|callable $class_name The name of the class to add. 
     * - A `string` can be provided, indicating the new Class Name.
     * - - You can prefix the string with a *Dollar Sign* (`$`) to indicate a *Class Property Name*, where the value of the property will be used as the Class Name.
     * - - You cannot provide a value that has already been added to the class. 
     * - A `callable` can also be provided that should return the new Class Name.
     * - - > `handler () : string`
     * @param callable|string|null $condition A condition used to manage the presence of the class.
     * - A `callable` can be provided that should indicate the presence of the class.
     * - - > `handler () : bool`
     * - - The handler should return **true** if the class should be present and **false** if it should not.
     * - A `string`, prefixed with a *Dollar Sign* (`$`), can also be provided. The string should indicate a *Class Property Name*, where the value of the property must be *Truthy* for the class to be present.
     * - If omitted, the class will *always* be present.
     * @param bool $return_identifier Indicates if the *Classname Identifier* should be returned instead of the updated object.
     * - This is only really useful when `$class_name` may be a `callable`, as it's required to remove them later.
     * @return string|$this Depending on the value of `$return_identifier`, returns the `object` for further chaining, or a `string` representing the *Classname Identifier*.
     * @throws \UnexpectedValueException if the `$class_name` or `$condition` is of an invalid type.
     */
    public function add_class ($class_name, $condition = null, bool $return_identifier = false) {
      // Argument Validations
      (function () use ($class_name, $condition) {
        if (!Validations\check_type($class_name, 'string|callable')) {
          throw new \UnexpectedValueException("The \$class_name must be a String or Callable.");
        }
        if (!Validations\check_type($condition, 'callable|string|null')) {
          throw new \UnexpectedValueException("If provided, the \$condition must be a Callable or String.");
        }
      })();

      $identifier = (function () use ($class_name) {
        if (is_callable($class_name)) {
          $identifier = '';

          while (true) {
            $identifier = 'callable#' . \ShiftCodesTK\Auth\random_token(6);

            if (!in_array($identifier, $this->html['classes'])) {
              break;
            }
          }

          return $identifier;
        }
        else {
          return $class_name;
        }
      })();

      $this->html['classes'][$identifier] = [
        'name'      => $class_name,
        'condition' => $condition
      ];

      if ($return_identifier) {
        return $identifier;
      }
      else {
        return $this;
      }
    }
    /** Remove a *Class* from the Form or Form Child.
     * 
     * @param string $class_name The name of the class to remove. If a `callable` is being removed, you must provide the *Classname Identifier* generated by `add_class()`.
     * @return $this Returns the object for further chaining.
     */
    public function remove_class (string $class_name) {
      $classes = &$this->html['classes'];

      if (array_key_exists($class_name, $classes)) {
        unset($classes[$class_name]);
      }
      else {
        trigger_error("Class \"{$class_name}\" has not been attached to element \"{$this->name}\".");
      }

      return $this;
    }
    /** Get a list of *Classes* that should be applied to the element.
     * 
     * @param bool $return_string Indicates if the classes should be returned as a `string`. Defaults to **false**.
     * @return string|array Returns an `array` or a `string` representing the *Classes* that should be applied to the element. 
     */
    public function get_classes (bool $return_string = false) {
      $classList = [];

      foreach ($this->html['classes'] as $classIdentifier => $classInfo) {
        $isActiveClass = (function () use ($classInfo) {
          if (is_string($classCondition) && Strings\substr_pos($classCondition, '$') === 0) {
            $propertyName = Strings\slice($classCondition, 1);

            return isset($this->$propertyName) && $this->$propertyName;
          }
          else if (is_callable($classCondition) && $classCondition()) {
            return true;
          }
          else if ($classCondition === true) {
            return true;
          }

          return false;
        })();
        
        if ($isActiveClass) {
          $parsedClassName = (function () use ($classIdentifier) {
            if (Strings\substr_pos($classIdentifier, '$') === 0) {
              $propertyName = Strings\slice($classIdentifier, 1);
  
              if (isset($this->$propertyName)) {
                return $this->$propertyName;
              }
              else {
                trigger_error("Property \"{$propertyName}\" is not available or accessible.");
              }
              
              return null;
            }
  
            return $classIdentifier;
          })();

          if (!isset($parsedClassName)) {
            continue;
          }
          
          $classList[] = $parsedClassName;
        }
      }

      if ($return_string) {
        return implode(' ', $classList);
      }
      else {
        return $classList;
      }
    }

    /** Add an *Attribute* to the Form or Form Child.
     * 
     * @param string $attr_name The name of the attribute to add. 
     * - You can prefix the string with a *Dollar Sign* (`$`) to indicate a *Class Property Name*, where the value of the property will be used as the Attribute Name.
     * @param string $attr_value The value of the attribute being added. 
     * - You can prefix the string with a *Dollar Sign* (`$`) to indicate a *Class Property Name*, where the value of the property will be used as the Attribute Value.
     * @param callable|string|null $condition A condition used to manage the presence of the attribute.
     * - A `callable` can be provided that manage the presence of the attribute.
     * - - > `condition (): bool`
     * - - The callable will be invoked when the element is being generated. The callable should return **true** when the attribute needs to be added to the element.
     * - A `string` can also be provided, prefixed with a *Dollar Sign* (`$`), indicating a *Class Property Name*, where the value of the property must be *Truthy* for the attribute to be added to the element.
     * - If omitted, the attribute will always be added to the element.
     * @return $this Returns the object for further chaining.
     */
    public function add_attribute (string $attr_name, string $attr_value, $condition = null) {
      if (!isset($this->html['attributes'][$attr_name])) {
        $this->html['attributes'][$attr_name] = [
          'value'     => $attr_value,
          'condition' => $condition ?? true
        ];
      }
      else {
        trigger_error("Attribute \"{$attr_name}\" has already been attached to element \"{$this->name}\".");
      }

      return $this;
    }
    /** Remove an *Attribute* from the Form or Form Child.
     * 
     * @param string $attr_name The name of the attribute to remove. 
     * @return $this Returns the object for further chaining.
     */
    public function remove_attribute (string $attr_name) {
      if (isset($this->html['attributes'][$attr_name])) {
        unset($this->html['attributes'][$attr_name]);
      }
      else {
        trigger_error("Attribute \"{$attr_name}\" has not been attached to element \"{$this->name}\".");
      }

      return $this;
    }
    /** Get a list of *Attributes* that should be applied to the element.
     * 
     * @param bool $return_string Indicates if the attributes should be returned as a `string`. Defaults to **false**.
     * @return string|array Returns an `array` or a `string` representing the *Attributes* that should be applied to the element. 
     */
    public function get_attributes (bool $return_string = false) {
      $attrList = [];

      foreach ($this->html['attributes'] as $attrName => $attrData) {
        $isActiveAttr = (function () use ($attrData) {
          $condition = $attrData['condition'];

          if (is_string($condition) && Strings\substr_pos($condition, '$') === 0) {
            $propertyName = Strings\slice($condition, 1);

            return isset($this->$propertyName) && $this->$propertyName;
          }
          else if (is_callable($condition) && $condition()) {
            return true;
          }
          else if ($condition === true) {
            return true;
          }

          return false;
        })();

        if ($isActiveAttr) {
          $parsedAttrName = (function () use ($attrName) {
            if (Strings\substr_pos($attrName, '$') === 0) {
              $propertyName = Strings\slice($attrName, 1);
  
              return isset($this->$propertyName)
                     ? Strings\encode_html($this->$propertyName)
                     : null;
            }
  
            return $attrName;
          })();
          $parsedAttrValue = (function () use ($attrData) {
            $attrValue = $attrData['value'];
  
            if (Strings\substr_pos($attrValue, '$') === 0) {
              $propertyName = Strings\slice($attrValue, 1);
  
              return isset($this->$propertyName)
                     ? Strings\encode_html($this->$propertyName)
                     : null;
            }
            else if ($attrValue === true) {
              return "";
            }
  
            return $attrValue;
          })();
  
          if (!isset($parsedAttrName) || !isset($parsedAttrValue)) {
            continue;
          }

          $attrList[$parsedAttrName] = $parsedAttrValue;
        }
      }

      if ($return_string) {
        $attrStr = '';

        foreach ($attrList as $attrName => $attrValue) {
          $attrStr .= "{$attrName}=\"{$attrValue}\" ";
        }

        return Strings\trim($attrStr, Strings\STR_SIDE_RIGHT);
      }
      else {
        return $attrList;
      }
    }

    /** Get a list of *Classes* & *Attributes* that should be applied to the element.
     * 
     * @param bool $return_string Indicates if the classes and attributes should be returned as a `string`. Defaults to **false**.
     * @return string|array Returns an `array` or a `string` representing the *Classes* & *Attributes* that should be applied to the element. 
     */
    public function get_attribute_markup (bool $return_string = false) {
      $classes = $this->get_classes($return_string);
      $attr = $this->get_attributes($return_string);

      if ($return_string) {
        $attributesStr = '';

        if (Strings\strlen($classes) > 0) {
          $attributesStr .= "class=\"{$classes}\" ";
        }
        if (Strings\strlen($attr) > 0) {
          $attributesStr .= "{$attr} ";
        }

        return Strings\trim($attributesStr, Strings\STR_SIDE_RIGHT);
      }
      else {
        return [
          'classes'    => $classes,
          'attributes' => $attr
        ];
      }
    }
  }