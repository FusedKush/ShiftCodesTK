<?php
  /** Database Functionality */

  use \ShiftCodesTK\Auth;

  /** Traits */
  /** Properties & Methods used for connecting to and querying the ShiftCodesTK Database */
  trait ShiftCodesTKDatabaseMysqliMixin {
    /**
     * @var mysqli|null|false The ShiftCodesTK Database Connection Handle. Represents the connection between PHP and the ShiftCodesTK Database.
     * - Has a value of **null** if the database connection has not yet been initialized.
     * - Has a value of **false** if an error occurred while connecting to the Database. 
     */
    private $mysqli = null;

    /**
     * Check for errors generated by a `mysqli` function.
     * 
     * @param bool $check_connection Indicates if the function should check for *connection errors* instead of *function call errors*.
     * @param callable $callback A function to be invoked if an error has occured.
     * @return true Returns **true** if no errors were generated by the last `mysqli` function call.
     * @throws Error Throws an error if the last `mysqli` function call generated an error.
     */
    public function check_mysqli_errors (bool $check_connection = false, callable $callback = null) {
      $errno = $check_connection
               ? 'connect_errno'
               : 'errno';

      if ($this->mysqli->$errno) {
        if ($callback) {
          $callback($this->mysqli);
        }
        
        throw new Error($this->mysqli->error);
      }

      return true;
    }
  }
  /** Properties & Methods used for verifying the integrity of a ShiftCodesTK Database Object */
  trait ShiftCodesTKDatabaseIntegrityMixin {
    /**
     * @var boolean Indicates if the database class is considered to be valid.
     * - Errors, especially in the object constructor, may cause this valid to become **false**.
     * - When **false**, most methods will fail with an exception thrown.
     */
    protected $is_valid = true;

    /**
     * Check the integrity of the database class
     * 
     * @return true Returns **true** if the database class is considered valid.
     * @throws Error Throws an error if the database class is not considered to be valid.
     */
    public function check_integrity () {
      if ($this->is_valid === false) {
        $className = get_class();

        throw new Error("{$className} has not been configured properly.");
      }

      return true;
    }
    /**
     * Trigger a fatal error, indicating that the database object can no longer be used.
     * 
     * @param Throwable $exception If provided, this is the Error Exception to be thrown alongside the fatal error.
     * @return boolean If no `$exception` is provided, returns **true** if the `$is_valid` property of the database object has been successfully updated. If the object was not updated, or if the object has already been compromised, returns **false**.
     * @throws Throwable If `$exception` is provided, it is thrown once the database object has been updated. 
     */
    public function fatal_error (Throwable $exception = null) {
      if ($this->is_valid === true) {
        $this->is_valid = false;

        if (isset($exception)) {
          throw $exception;
        }
        else {
          return $this->is_valid === false;
        }
      }

      return false;
    }
  }

  /** Extensions */
  /** Options for ShiftCodesTK Database Queries */
  class ShiftCodesTKDatabaseQueryOptions {
    /**
     * @var array `ValidationProperties` configuration settings for the options.
     * - See `$VALIDATION_PROPERTIES` for the full, compiled list of validation properties.
     */
    private const VALIDATIONS = [
      'allow_multiple_queries' => [
        'type'                    => 'boolean'
      ],
      'get_result_set_data'    => [
        'type'                    => 'boolean'
      ],
      'get_field_metadata'     => [
        'type'                    => 'boolean|string',
        'validations'             => [
          'match'                    => [
            false,
            true,
            'ADVANCED'
          ]
        ]
      ],
      'create_response_object' => [
        'type'                    => 'boolean'
      ],
      'log_response_issues'    => [
        'type'                    => 'boolean'
      ],
      'collapse_query_result'  => [
        'type'                    => 'boolean'
      ],
      'collapse_result'        => [
        'type'                    => 'boolean'
      ],
      'collapse_result_data'   => [
        'type'                    => 'boolean'
      ],
      'collapse_row'           => [
        'type'                    => 'boolean'
      ],
      'collapse_all'           => [
        'type'                    => 'boolean'
      ],
      'format_parameters'      => [
        'type'                    => 'array'
      ]
    ];

    /**
     * @var array A list of compiled `ValidationProperties` objects for each of the query options.
     * - See `VALIDATIONS` for the definition list of validation properties.
     */
    public static $VALIDATION_PROPERTIES = [];

    /** 
     * @var boolean Indicates if multiple queries can be executed using a delimiter.
     * - Has no effect when using `prepared_query()`.
     **/
    public $allow_multiple_queries = false;
    /**
     * @var boolean Indicates if the `Result Set Data` for the request should be included.
     * - If **true**, result set data will be returned *for every query*. This option should be used sparingly when multiple queries are being executed.
     * - Only supports queries that return a result set, such as `SELECT`.
     * - Retrieved via the `$result_set` property of the `ShiftCodesTKDatabaseQuery`.
     */
    public $get_result_set_data = false;
    /**
     * @var boolean|"ADVANCED" Indicates if the `Field Metadata` for the request should be included.
     * - When present, field metadata will be returned for *every field included the query, for every query*. This option should be used sparingly when retrieving many fields simultaneously, or when multiple queries are being executed.
     * - Only supports queries that return a result set, such as `SELECT`.
     * - Retrieved via the `$field_metadata` property of the `ShiftCodesTKDatabaseQuery`.
     * - If the keyword **"ADVANCED"** is passed, *Advanced Metadata* will also be returned. See `ShiftCodesTKDatabaseQueryResultFieldMetadata::get_metadata()` for more information on this value.
     */
    public $get_field_metadata = false;
    /**
     * @var boolean Indicates if a `ResponseObject` should be created for the query.
     * - Retrieved via the `$response` property of the `ShiftCodesTKDatabaseQuery`.
     */
    public $create_response_object = false;
    /**
     * @var boolean Indicates if warnings and errors should be logged to the query's `ResponseObject`.
     * - Issues are retrieved via the `warnings` and `errors` properties of the `$response` property of the `ShiftCodesTKDatabaseQuery`.
     */
    public $log_response_issues = false;
    /**
     * @var boolean If **true**, a single query result will automatically be collapsed to just the returned result set.
     * - Example: `[ [ [ 'result' => [ 'id' => 1 ] ] ] ]` becomes `[ [ 'result' => [ 'id' => 1 ] ] ]`
     */
    public $collapse_query_result = false;
    /**
     * @var boolean If **true**, a single result will automatically be collapsed to just the returned row.
     * - Example: `[ [ 'result' => [ 'id' => 1 ] ] ]` becomes `[ 'result' => [ 'id' => 1 ] ]`
     */
    public $collapse_result = false;
    /**
     * @var boolean If **true**, the query result data will automatically be collapsed to just the result.
     * - Example: `[ 'result' => [ 'id' => 1 ] ]` becomes `[ 'id' => 1 ]`
     */
    public $collapse_result_data = false;
    /**
     * @var boolean If **true**, a single row will automatically be collapsed to just the returned value.
     * - Example: `[ 'id' => 1 ]` becomes `1`
     */
    public $collapse_row = false;
    /**
     * @var boolean If **true**, single results, single query results, & single rows will automatically be collapsed.
     * - This is the same as setting `$collapse_result`, `$collapse_query_result`, & `collapse_row` to **true**.
     * - Example: `[ [ [ 'result' => [ 'id' => 1 ] ] ] ]` becomes `1`
     */
    public $collapse_all = false;
    /**
     * @var array A list of fields and how they are to be transformed before being returned.
     * - Each field contains an `array` with one or more of the following values:
     * - - `true $format_date`: When **true**, the date time value will be converted to ISO 8601 format.
     * - - `string $use_timezone`: When a *timezone field name* is provided, the date time value will be modified to include the included *timezone*.
     * - - `string $change_type`: When a *variable type* is provided, the value will be typecasted to the provided type. 
     */
    public $format_parameters = [];

    /** Initialize the `ShiftCodesTKDatabaseQueryOptions` class */
    public function __construct () {
      // Compile Validation Properties
      (function () {
        if (count(self::$VALIDATION_PROPERTIES) == 0) {
          foreach ($this::VALIDATIONS as $optionName => $optionConfiguration) {
            $compiledConfiguration = array_replace_recursive($optionConfiguration, [ 'value' => $this->$optionName ]);
  
            self::$VALIDATION_PROPERTIES[$optionName] = new ValidationProperties($compiledConfiguration);
          }
        }
      })();

      return $this;
    }
  }
  /** Represents variable bindings for use in a *Prepared Query* */
  class ShiftCodesTKDatabasePreparedVariables {
    use ShiftCodesTKDatabaseIntegrityMixin;

    /**
     * @var string The *Type String* used to indicate the type of variables being substituted in the `query`.
     * - Each variable is represented using one of the following letters:
     * - - `i` - Integer
     * - - `d` - Double (Float)
     * - - `s` - String
     * - - `b` - Blob
     */
    public $type_string = '';
    /**
     * @var array The variables to be binded to the *Prepared Query*.
     * - Variable Sets are queried in the order they are indexed.
     * - Variables are substituted into the `query` in the order they are indexed.
     */
    public $variables = [];

    /**
     * Initialize a new set of Prepared Variables
     * 
     * @param string $type_string The *Type String* used to indicate the type of variables being substituted in the `query`.
     * - Each variable is represented using one of the following letters:
     * - - `i` - Integer
     * - - `d` - Double (Float)
     * - - `s` - String
     * - - `b` - Blob
     * @param array $variables The variables to be binded to the *Prepared Query*.
     * - Multiple sets of variables can be provided as additional arguments to the function.
     * - Alternatively, this argument can be omitted, and you can use the `change_variables()` method to execute repeated queries instead.
     * @return ShiftCodesTKDatabasePreparedVariables|false Returns an object representing the variable bindings to be used in a *Prepared Query*. If an error occurs, returns **false**.
     */
    public function __construct (string $type_string, array ...$variables) {
      try {
        if (!strlen($type_string)) {
          throw new Error("A valid Parameter Type String was not provided.");
        }

        if ($variables) {
          foreach ($variables as $var_list) {
            if (!is_array($var_list)) {
              throw new TypeError("Variable lists must be provided in the form of arrays.");
            }
          }
          
          $this->variables = $variables;
        }

        $this->type_string = $type_string;
  
        return $this;
      }
      catch (\Throwable $exception) {
        $this->fatal_error();
        trigger_error("Failed to save Prepared Variables: {$exception->getMessage()}");
      }
    }
    /**
     * Update the *Prepared Variables* with new data
     * 
     * @param ShiftCodesTKDatabaseQuery|false $execute_query If a `ShiftCodesTKDatabaseQuery` is provided, it will be executed once the new variables have been bound. 
     * @param array $variables An array of *Variables* to be bound to the Prepared Statement. Multiple sets of variables can be provided as additional arguments.
     * @return ShiftCodesTKDatabaseQueryResult|bool Returns a value based on the value of `$execute_query`:
     * - If `$execute_query` is **false**, a `boolean` will be returned, returning **true** on success or **false** if an error occurred.
     * - If `$execute_query` is not **false**, returns a `ShiftCodesTKDatabaseQueryResult` on success, or **false** if an error occurred.
     */
    public function change_variables ($execute_query = false, ...$variables) {
      try {
        if (!count($variables)) {
          throw new Error("No variables for binding were provided.");
        }

        foreach ($variables as $var_list) {
          if (!is_array($var_list)) {
            throw new TypeError("Variable lists must be provided in the form of arrays.");
          }
        }
        
        $this->variables = $variables;

        if ($execute_query) {
          return $execute_query->query();
        }
        else {
          return true;
        }
      }
      catch (\Throwable $exception) {
        trigger_error("Failed to change Prepared Variables: {$exception->getMessage()}");
        return false;
      }
    }
  }
  /** Represents the result of a Database Query */
  class ShiftCodesTKDatabaseQueryResult {
    /**
     * @var mixed The Result of the Database Query. 
     * - Use the `get_result()` method of the `ShiftCodesTKDatabaseQuery` to retrieve this value.
     */
    public $result = null;
    /**
     * @var array|null An array made up of metadata related to the *queried fields*.
     * - Requires the `get_field_metadata` option to be set to **true** to be populated.
     * - Each field returned by the query is indexed with the following properties:
     * | Property | Description |
     * | --- | --- |
     * | name | The name of the column |
     * | orgname | Original column name if an alias was specified |
     * | table | The name of the table this field belongs to (if not calculated) |
     * | orgtable | Original table name if an alias was specified |
     * | def | Reserved for default value, currently always "" |
     * | db | Database (since PHP 5.3.6) |
     * | catalog | The catalog name, always "def" (since PHP 5.3.6) |
     * | max_length | The maximum width of the field for the result set. |
     * | length | The width of the field, as specified in the table definition. |
     * | charsetnr | The character set number for the field. |
     * | flags | An integer representing the bit-flags for the field. |
     * | type | The data type used for this field |
     * | decimals | The number of decimals used (for integer fields) |
     */
    public $field_metadata = null;
    /**
     * @var array|null An array made up of `ShiftCodesTKDatabaseQueryResultData` objects for each executed query.
     * - Requires the `get_result_set_data` option to be set to **true** to be populated.
     */
    public $result_set = null;

    /**
     * Initialize a new Database Query Result
     * 
     * @param array $result_data An array made up of the result data, corresponding to the properties of the `ShiftCodesTKDatabaseQueryResult` object.
     * @return \ShiftCodesTKDatabaseQueryResult|false Returns an object representing the result of the database query. If an error occurs, returns **false**.
     */
    public function __construct (array $result_data) {
      foreach ($result_data as $property_name => $property_value) {
        if (($this->$property_name ?? false) !== false) {
          trigger_error("\"{$property_name}\" is not a valid property value.", E_USER_WARNING);
          continue;
        }

        $this->$property_name = $property_value;
      }
    }
  }
  /** Represents the *Field Metadata* of a Database Query */
  class ShiftCodesTKDatabaseQueryResultFieldMetadata {
    /** @var array A list of properties that are considered *advanced*. */
    private const ADVANCED_METADATA = [
      'orgname',
      'orgtable',
      'db',
      'org_full_name',
      'complete_name',
      'org_complete_name',
      'def',
      'catalog',
      'max_length',
      'length',
      'charsetnr',
      'flags',
      'type',
      'decimals'
    ];

    /** @var string The name of the column. */
    public $name = '';
    /** @var string The original name of the column if an *alias* was specified. */
    public $orgname = '';
    /** @var string The name of the table the field belongs to (if not calculated). */
    public $table = '';
    /** @var string The original name of the table if an *alias* was specified. */
    public $orgtable = '';
    /** @var string The database the `$table` belongs to. */
    public $db = '';
    /** @var string The full name of the column, made up of the `$table` & `$name`. */
    public $full_name = '';
    /** @var string The original full name of the column if any *alias's* were specified. Made up of the `$orgtable` & `$orgname`. */
    public $org_full_name = '';
    /** @var string The complete name of the column, made up of the `$db`, `$table` & `$name`. */
    public $complete_name = '';
    /** @var string The original complete name of the column if any *alias's* were specified. Made up of the `$db`, `$orgtable` & `$orgname. */
    public $org_complete_name = '';
    /** 
     * @var string The default value of the field. 
     * - Currently, this value is always `""`.
     **/
    public $def = '';
    /** 
     * @var string The catalog name.
     * - Currently, this value is always `""`.
     **/
    public $catalog = '';
    /** @var int The maximum width of the field for the *Result Set*. */
    public $max_length = 0;
    /** @var int The width of the field, as specified in the table definition. */
    public $length = 0;
    /** @var int The character set number for the field. */
    public $charsetnr = 0;
    /** @var int An integer representing the bit-flags for the field. */
    public $flags = 0;
    /** @var array An array representing all of the active flags for the field. */
    public $flags_array = [];
    /** @var string An integer representing the data type used for the field. */
    public $type = 0;
    /** @var string A string representing the data type used for the field. */
    public $type_name = '';
    /** @var int The number of decimals used for *integer* fields. */
    public $decimals = 0;

    /**
     * Initialize a new Field Metadata Object
     * 
     * @param stdClass $field_metadata An object made up of field metadata, retrieved by calling `mysqli_result::fetch_field()`.
     */
    public function __construct($field_metadata) {
      foreach ($field_metadata as $property => $value) {
        if (isset($this->$property)) {
          $this->$property = $value;
        }
      }

      if ($this->orgname) {
        $this->full_name = "{$this->table}.{$this->name}";
        $this->org_full_name = "{$this->orgtable}.{$this->orgname}";
  
        $this->complete_name = "{$this->db}.{$this->table}.{$this->name}";
        $this->org_complete_name = "{$this->db}.{$this->orgtable}.{$this->orgname}";
      }

      $this->flags_array = ShiftCodesTKDatabase::get_field_flags($this->flags, 'FLAG_ARRAY');
      $this->type_name = ShiftCodesTKDatabase::get_field_type_info($this->type)['name'];
    }
    /**
     * Retrieve the metadata from field
     * 
     * @param bool $get_advanced_metadata Indicates if *Advanced Metadata* should be included in the result, including the following properties:
     * - `orgname`
     * - `orgtable`
     * - `def`
     * - `db`
     * - `catalog`
     * - `max_length`
     * - `length`
     * - `charsetnr`
     * - `flags`
     * - `type`
     * - `decimals`
     * @return \ShiftCodesTKDatabaseQueryFieldMetadata Returns an object representing the field metadata, the inclusion of some properties dependent on the value of `$get_advanced_metadata`. 
     */
    public function get_metadata ($get_advanced_metadata = false) {
      $result = clone $this;

      if (!$get_advanced_metadata) {
        foreach ($this::ADVANCED_METADATA as $property) {
          unset($result->$property);
        }
      }

      return $result;
    }
  }
  /** Represents the *Result Set Data* of a Database Query */
  class ShiftCodesTKDatabaseQueryResultSetData {
    /**
     * @var int The maximum number of items in a Result Set Chunk.
     */
    public $max_chunk_size = null;
    /**
     * @var int The number of items in the current Result Set Chunk.
     */
    public $current_chunk_size = null;
    /**
     * @var int The total number of items in all Result Set Chunks.
     */
    public $total_chunk_size = null;
    /**
     * @var int The current chunk number. Starts at **1**, up to the value of `$total_chunks`.
     */
    public $current_chunk = null;
    /**
     * @var int The total number of chunks.
     */
    public $total_chunks = null;
    /**
     * @var bool Indicates if a previous Result Set Chunk can be retrieved.
     */
    public $has_previous_chunk = false;
    /**
     * @var bool Indicates if the next Result Set Chunk can be retrieved.
     */
    public $has_next_chunk = false;
    /**
     * @var array An array of `Item Numbers` representing the contents of the current Result Set Chunk. `Item Numbers` start at **1**, up to the `$total_chunk_size`
     */
    public $chunk_contents = [];

    /**
     * Initialize a new Result Set Data Object
     * 
     * @param string $queryString The query string of the Result Set.
     * @param int $currentChunkSize The size of the current Result Set Chunk.
     * @param int $totalResultChunkSize The total number of items that are a part of the Result Set Chunk.
     * @return true Returns **true** on success.
     */
    public function __construct(string $queryString, int $currentChunkSize, int $totalResultChunkSize) {
      $this->max_chunk_size = (function () use ($queryString, $totalResultChunkSize) {
        $max = $totalResultChunkSize;
        $matches = [];

        if (preg_match('/(\bLIMIT\b)(?!.*\b\1\b) (\d+)/i', $queryString, $matches)) {
          $max = $matches[2];
        }

        return (int) $max;
      })();
      $this->current_chunk_size = $currentChunkSize;
      $this->total_chunk_size = $totalResultChunkSize;
      $this->current_chunk = (function () use ($queryString) {
        $chunk = 1;
        $matches = [];

        if ($this->max_chunk_size > 0 && preg_match('/(\bOFFSET\b)(?!.*\b\1\b) (\d+)/i', $queryString, $matches)) {
          $newChunk = ($matches[2] / $this->max_chunk_size) + 1;

          if ($newChunk > 0) {
            $chunk = $newChunk;
          }
        }

        return $chunk;
      })();
      $this->total_chunks = (int) ceil($totalResultChunkSize / $this->max_chunk_size);
      $this->has_previous_chunk = $this->current_chunk != 1;
      $this->has_next_chunk = $this->current_chunk != $this->total_chunks;
      $this->chunk_contents = (function () {
        $items = [];

        $lastItem = $this->max_chunk_size * $this->current_chunk;
        $firstItem = $lastItem - ($this->max_chunk_size - 1);

        for ($resultIndex = 0; $resultIndex < $this->current_chunk_size; $resultIndex++) {
          $items[] = $firstItem + $resultIndex;
        }

        return $items;
      })();

      return true;
    }
  };

  /** Classes */
  /** Represents a connection to the ShiftCodesTK Database */
  class ShiftCodesTKDatabase {
    use ShiftCodesTKDatabaseMysqliMixin;

    /**
     * @var array A list of date-time formats to use with the database.
     * 
     * | Name | Value |
     * | --- | --- |
     * | `date` | Y-m-d |
     * | `time` | H:i:s |
     * | `date_time` | Y-m-d H:i:s |
     * | `full_date` | Y-m-d H:i:s.u |
     */
    public const DATE_FORMATS = [
      'date'      => 'Y-m-d',
      'time'      => 'H:i:s',
      'date_time' => 'Y-m-d H:i:s',
      'full_date' => 'Y-m-d H:i:s.u'
    ];
    /**
     * A list of *Field Types* and their respective categories.
     * - See `$FIELD_TYPES` for the compiled list of *Field Types*.
     * - Use `get_field_type_info()` to retrieve information about a specific *Field Type*.
     */
    private const FIELD_TYPES = [
      'types'     => [
        'DECIMAL'    => 'DECIMAL',
        'TINYINT'    => 'TINY',
        'SMALLINT'   => 'SHORT',
        'INT'        => 'LONG',
        'FLOAT'      => 'FLOAT',
        'DOUBLE'     => 'DOUBLE',
        'NULL'       => 'NULL',
        'TIMESTAMP'  => 'TIMESTAMP',
        'BIGINT'     => 'LONGLONG',
        'MEDIUMINT'  => 'INT24',
        'DATE'       => 'DATE',
        'TIME'       => 'TIME',
        'DATETIME'   => 'DATETIME',
        'YEAR'       => 'YEAR',
        'DATE'       => 'NEWDATE',
        'ENUM'       => 'ENUM',
        'SET'        => 'SET',
        'TINYBLOB'   => 'TINY_BLOB',
        'MEDIUMBLOB' => 'MEDIUM_BLOB',
        'LONGBLOB'   => 'LONG_BLOB',
        'BLOB'       => 'BLOB',
        'VARCHAR'    => 'VAR_STRING',
        'STRING'     => 'STRING',
        'CHAR'       => 'CHAR',
        'INTERVAL'   => 'INTERVAL',
        'GEOMETRY'   => 'GEOMETRY',
        'JSON'       => 'JSON',
        'NUMERIC'    => 'NEWDECIMAL',
        'BIT'        => 'BIT'
      ],
      'categories' => [
        'numeric' => [
          'BIT',
          'TINYINT',
          'SMALLINT',
          'MEDIUMINT',
          'INT',
          'BIGINT',
          'DECIMAL',
          'NUMERIC',
          'FLOAT',
          'DOUBLE'
        ],
        'string'  => [
          'CHAR',
          'VARCHAR',
          'STRING'
        ],
        'date'    => [
          'DATE',
          'DATE',
          'YEAR',
          'DATETIME',
          'INTERVAL',
          'TIMESTAMP'
        ],
        'set'     => [
          'ENUM',
          'SET'
        ],
        'blob'    => [
          'TINYBLOB',
          'MEDIUMBLOB',
          'LONGBLOB',
          'BLOB'
        ],
        'misc'    => [
          'NULL',
          'GEOMETRY',
          'JSON'
        ]
      ]
    ];

    /** 
     * @var ShiftCodesTKDatabase|null|false The active instance of the `ShiftCodesTKDatabase`.
     * - Has a value of **null** if an instance has not been created yet. 
     * - Has a value of **false** if an instance could not be created.
     **/
    private static $instance = null;
    /**
     * A list of *Field Types* and their respective information.
     * - See `FIELD_TYPES` for the definition list of *Field Types* and their respective categories.
     * - Use `get_field_type_info()` to retrieve information about a specific *Field Type*.
     */
    public static $FIELD_TYPES = [];
    /**
     * A list of *Field Types* and their respective information.
     * - See `FIELD_TYPES` for the definition list of *Field Types* and their respective categories.
     * - Use `get_field_type_info()` to retrieve information about a specific *Field Type*.
     */
    public static $FIELD_FLAGS = [];

    /**
     * Initialize the connection to the ShiftCodesTK Database
     * 
     * @return ShiftCodesTKDatabase Returns an object representing a connection to the ShiftCodesTK Database. You can check if `$instance` is equal to **false** to check if an error occurred during initialization.
     */
    public function __construct () {
      try {
        // Compile Field Types
        (function () {
          foreach (self::FIELD_TYPES['types'] as $typeName => $constName) {
            $fullConstName = "MYSQLI_TYPE_{$constName}";
            $category = (function () use ($typeName) {
              foreach (self::FIELD_TYPES['categories'] as $categoryName => $categoryTypeList) {
                foreach ($categoryTypeList as $categoryTypeName) {
                  if ($typeName == $categoryTypeName) {
                    return $categoryName;
                  }
                }
              }
            })();

            self::$FIELD_TYPES[] = [
              'name'     => $typeName,
              'constant' => $fullConstName,
              'int'      => constant($fullConstName),
              'category' => $category
            ];
          }
        })();
        // Compile Field Flags
        (function () {
          $consts = get_defined_constants(true)['mysqli'];

          foreach ($consts as $constName => $constValue) {
            $matches = [];

            if (preg_match('/MYSQLI_(\w+)_FLAG/', $constName, $matches)) {
              self::$FIELD_FLAGS[] = [
                'name'     => str_replace('_', ' ', $matches[1]),
                'constant' => $constName,
                'int'      => $constValue
              ];
            }
          }
        })();

        $this->mysqli = new mysqli(...array_values(ShiftCodesTKSecrets::getSecret('db')));
        $this->check_mysqli_errors(true);
  
        // Set Session Timezone to UTC
        (function () {
          $result = $this->mysqli->query("SET @@session.time_zone = '+00:00'");

          if (!$result) {
            throw new \Error("Failed to set Session Timezone: {$this->con->connect_error}");
          }
        })();
        // Set Default Charset
        (function () {
          $result = $this->mysqli->set_charset('utf8mb4');

          if (!$result) {
            throw new \Error("Failed to update the Default Character Set Encoding.");
          }
        })();
  
        return $this;
      }
      catch (Exception $exception) {
        trigger_error("Database Connection Failed: {$exception->getMessage()}");
        $this->mysqli = false;
      }
    }

    /**
     * Retrieve the active instance of the `ShiftCodesTKDatabase`
     * 
     * @return ShiftCodesTKDatabase|false Returns the active instance of the `ShiftCodesTKDatabase`, or **false** if one is not available.
     */
    public static function get_instance () {
      if (self::$instance === null) {
        self::$instance = new ShiftCodesTKDatabase();
      }

      return self::$instance;
    }
    /**
     * Retrieve the active *connection handle* for the `ShiftCodesTKDatabase`
     * 
     * @return mysqli|false Returns the `mysqli` connection handle of the `ShiftCodesTKDatabase`, or **false** if it is not available.
     */
    public static function get_handle () {
      $instance = self::get_instance();

      if ($instance) {
        return self::get_instance()->mysqli;
      }
      else {
        return false;
      }
    }
    /**
     * Begin a new *Transaction* on the database
     * - You *must* call `close_transaction()` after the query (or queries) for the changes to be pushed to the database.
     * 
     * @param int $flags A bitmask of `MYSQLI_TRANS_START` constants to be passed to the `mysqli->begin_transaction()` method.
     * - Note that by default the transaction type will be determined based on the query contents.
     * 
     * | Constant | Description |
     * | --- | --- |
     * | MYSQLI_TRANS_START_READ_ONLY | Prepends `START TRANSACTION READ ONLY` to the transaction statement, indicating that the transaction will not be updating any tables. |
     * | MYSQLI_TRANS_START_READ_WRITE | Prepends `START TRANSACTION READ WRITE` to the transaction statement, indicating that the transaction will be updating tables. |
     * | MYSQLI_TRANS_START_WITH_CONSISTENT_SNAPSHOT | Prepends `START TRANSACTION WITH CONSISTENT SNAPSHOT` to the transaction statement, indicating a [Consistent Read](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_consistent_read) operation. |
     * @return string|false Returns the *Transaction ID* on success, or **false** if an error occurred.
     */
    public static function start_transaction (int $flags = 0) {
      $transaction_id = Auth\random_unique_id(30, 'TR', Auth\UNIQUE_ID_TYPE_TOKEN);

      $result = self::get_handle()->begin_transaction($flags, $transaction_id);

      if ($result) {
        return $transaction_id;
      }
      else {
        return false;
      }
    }
    /**
     * Close an existing *Transaction*
     * 
     * @param string $transaction_id The *Transaction ID* returned by `start_transaction()`.
     * @param bool $transaction_result Indicates if the transaction was *successful* or not.
     * - If **true**, the transaction will be *committed*.
     * - If **false**, the transaction will be *rolled back*.
     * @param int $flags A bitmask of `MYSQLI_TRANS_COR` constants to be passed to the `mysqli->commit()` and `mysqli->rollback()` methods.
     * 
     * | Constant | Description |
     * | --- | --- |
     * | MYSQLI_TRANS_COR_AND_CHAIN | Appends `AND CHAIN` to the transaction statement, causing a new transaction to begin as soon as the current one ends. |
     * | MYSQLI_TRANS_COR_AND_NO_CHAIN | Appends `AND NO CHAIN` to the transaction statement. |
     * | MYSQLI_TRANS_COR_RELEASE | Appends `RELEASE` to the transaction statement, causing the server to disconnect after the current transaction ends. | 
     * | MYSQLI_TRANS_COR_NO_RELEASE | Appends `NO RELEASE` to the transaction statement. |
     * @return boolean Returns **true** on success, or **false** on failure.
     */
    public static function close_transaction (string $transaction_id, bool $transaction_result = true, int $flags = -1) {
      $handle = self::get_handle();

      if ($transaction_result) {
        return $handle->commit($flags, $transaction_id);
      }
      else {
        return $handle->rollback($flags, $transaction_id);
      }
    }
    /**
     * Escape a string for use in a SQL Query Statement
     * 
     * The following characters are escaped:
     * - `NUL` (ASCII 0)
     * - `\n`
     * - `\r`
     * - `\`
     * - `'`
     * - `"`
     * - `Control-Z`
     * 
     * @param string $string The string to be escaped.
     * @return string Returns the escaped string.
     */
    public static function escape_string ($string) {
      $cleanStr = $string;

      // $cleanStr = collapseWhitespace($cleanStr);
      $cleanStr = \ShiftCodesTK\Strings\collapse($cleanStr);
      $cleanStr = self::get_handle()->real_escape_string($cleanStr);

      return $cleanStr;
    }
    /**
     * Retrieve information about a given *Field Type*.
     * 
     * @param int|string $field_type The *Field Type* you are retrieving information about. 
     * - Note that this parameter is *case-insensitive*.
     * - Can be one of the following values:
     * - - **Field Type Integer**: The constant integer value of the field type, such as _253_.
     * - - **Field Type Name**: The type name of the field type, such as _"VARCHAR"_.
     * - - **Field Type Constant**: The name of the constant belonging to the field type, such as _"MYSQLI_TYPE_VAR_STRING"_.
     * @param "int|"name"|"constant" $field_type_identifier Indicates the type of value that was provided to the `$field_type`.
     * @return array|false 
     * - On success, returns an `associative array` containing information about the *Field Type*:
     * | Key | Value |
     * | --- | --- |
     * | `name` | The type name of the field type. |
     * | `constant` | The name of the constant belonging to the field type. |
     * | `int` | The integer value of the field type. |
     * | `category` | The category the field type belongs to. |
     * - If an invalid `$field_type` or `$field_type_identifier` was provided, returns **false**.
     */
    public static function get_field_type_info ($field_type, $field_type_identifier = "int") {
      foreach (self::$FIELD_TYPES as $typeInfo) {
        if ($field_type_identifier == 'category' || !isset($typeInfo[$field_type_identifier])) {
          trigger_error("\"{$field_type_identifier}\" is not a valid Field Type Identifier.");
          return false;
        }
        if (strtolower($typeInfo[$field_type_identifier]) == strtolower($field_type)) {
          return $typeInfo;
        }
      }

      return false;
    }
    /**
     * Retrieve the flags for a given field using its *Bit-Flags Integer*
     * 
     * @param int $field_flags The *Bit-Flags Integer* for the field. 
     * @param ""FLAG_STRING"|"FLAG_ARRAY"|"INFO_ARRAY" $return_value Indicates how to format the return value:
     * 
     * | Value | Return Value |
     * | --- | --- |
     * | `"FLAG_STRING"` | Returns a comma-separated `string` containing the names of all present flags. |
     * | `"FLAG_ARRAY"` | Returns an `array` made up of the names of all present flags. |
     * | `"INFO_ARRAY"` | Returns an `associative array` made up of information about all present flags. |
     * @return string|array|false On success, returns a `string` or `array` depending on the value of `$return_value`. If an error occurrs, returns **false**.
     */
    public static function get_field_flags ($field_flags, $return_value = 'FLAG_STRING') {
      $flags = [];

      foreach (self::$FIELD_FLAGS as $flagInfo) {
        if ($field_flags & $flagInfo['int']) {
          if ($return_value == 'INFO_ARRAY') {
            $flags[] = $flagInfo;
          }
          else {
            $flags[] = $flagInfo['name'];
          }
        }

      }
      
      // if (count($flags) == 0) {
      //   return false;
      // }
      if ($return_value == 'FLAG_STRING') {
        return implode(', ', $flags);
      }
      else {
        return $flags;
      }
    }
  }
  /** Represents a query for the ShiftCodesTK Database */
  class ShiftCodesTKDatabaseQuery {
    use ShiftCodesTKDatabaseMysqliMixin, 
        ShiftCodesTKDatabaseIntegrityMixin;

    /**
     * @var string The query string used to query the database.
     */
    public $query = null;
    /**
     * @var ShiftCodesTKDatabaseQueryOptions The list of options used to configure the query and returned results.
     */
    public $options = null;
    /**
     * @var ShiftCodesTKDatabasePreparedVariables|null Variable bindings for use in a *Prepared Query*.
     * - The presence of this property indicates if the query is a *Prepared Query* or not.
     */
    public $prepared_variables = null;
    /**
     * @var array An array of returned `ShiftCodesTKDatabaseQueryResult` objects. Use `get_result()` to retrieve the formatted results.
     */
    public $result = null;
    /**
     * @var ResponseObject|null The `ResponseObject` of the query. 
     * - Requires the `get_response_object` option to be **true** to be populated.
     * - The `payload` will *never* be populated within this property. Use `get_response()` to retrieve the full `ResponseObject`. 
     */
    public $response = null;

    /**
     * Create a new query for the ShiftCodesTK Database
     * 
     * @param string $query The query string used to query the database.
     * - This value is *not* automatically sanitized. You can use `ShiftCodesTKDatabase::clean_string()` to sanitize the string.
     * @param array $options An array of `ShiftCodesTKDatabaseQueryOptions` to configure the query with.
     * @param \ShiftCodesTKDatabasePreparedVariables|null $prepared_variables An object representing the parameters to be binded to a *prepared statement*.
     * @return \ShiftCodesTKDatabaseQuery|false Returns an object representing a query for the database. If an error occurred, returns **false**.
     */
    public function __construct($query, array $options = [], ShiftCodesTKDatabasePreparedVariables $prepared_variables = null) {
      try {
        $queryType = $prepared_variables === null
                     ? 'standard'
                     : 'prepared';
        
        $this->mysqli = ShiftCodesTKDatabase::get_handle();

        if ($options['create_response_object'] ?? false) {
          $this->response = new ResponseObject();
        }

        if ($this->mysqli === false) {
          throw new Error("A connection to the database could not be established.");
        }

        // Set Query
        (function () use ($query, $prepared_variables, $queryType, $options) {
          /** The number of queries found in the `query` */
          $queryCount = (function () use ($query) {
            $count = substr_count($query, ';');
    
            if ($count > 1) {
              return $count;
            }
            else if ($count == 1) {
              return 1;
            }
            else {
              return 1;
            }
          })();
          $replacementCount = substr_count($query, '?');
          $queryStr = $query;
  
          $queryStr = collapseWhitespace($queryStr);
  
          if (strlen($queryStr) == 0) {
            throw new Error('Query cannot be empty');
          }
          if ($queryCount > 1) {
            if ($queryType == 'prepared') {
              throw new Error("Multiple queries are not permitted when using Prepared Statements.");
            }
            if (!($options['allow_multiple_queries'] ?? false)) {
              throw new Error("Multiple queries are not permitted.");
            }
          }
          if ($queryType == 'standard') {
            if ($replacementCount > 0) {
              throw new Error("Replacements were found in the query string, but no prepared data was provided.");
            }
          }
          if ($queryType == 'prepared') {
            $replacementCount = substr_count($queryStr, '?');
            $bindingCount = strlen($prepared_variables->type_string);

            if ($replacementCount == 0) {
              throw new Error("No replacements were found in the query string for a Prepared Statements.");
            }
            if ($replacementCount != $bindingCount) {
              throw new Error("The number of replacements in the query statement does not match the number of bound variables. {$bindingCount} expected, but {$replacementCount} provided.");
            }
          }
  
          $this->query = $queryStr;
        })();
        // Set Options
        (function () use ($options) {
          $optionList = new ShiftCodesTKDatabaseQueryOptions();
          $validatedOptions = check_parameters($options, $optionList::$VALIDATION_PROPERTIES);
  
          if ($validatedOptions['valid']) {
            foreach ($validatedOptions['parameters'] as $optionName => $optionValue) {
              $optionList->$optionName = $optionValue;
            }

            $this->options = $optionList;
          }
          else {
            foreach ($validatedOptions['errors'] as $error) {
              $errorStr = print_r($error, true);
  
              throw new Error("Invalid Option: {$errorStr}");
            }
          }
  
          foreach ($validatedOptions['warnings'] as $warning) {
            $warningStr = print_r($warning, true);
  
            if ($this->options->create_response_object && $this->options->log_response_issues) {
              $this->response->setWarning($warning);
            }

            trigger_error("Invalid ShiftCodesTKDatabaseQuery Option: {$warningStr}", E_USER_WARNING);
          }
        })();
        // Prepared Variables
        (function () use ($prepared_variables, $queryType) {
          if ($queryType == 'prepared') {
            $this->prepared_variables = $prepared_variables;
          }
        })();

        return $this;
      }
      catch (\Throwable $exception) {
        if ($options['create_response_object'] ?? false) {
          $this->response->set(500);

          if ($options['log_response_issues'] ?? false) {
            $this->response->setError(errorObject('DatabaseQueryError', null, $exception->getMessage()));
          }
        }

        trigger_error("Failed to create the Database Query: {$exception->getMessage()}");
        $this->fatal_error();
      }
    }
    /**
     * Perform a query on the database
     * 
     * @return mixed Returns the result of the query on success. See `get_result()` for more information on this value. If the query fails, returns **false**.
     */
    public function query () {
      try {
        $this->check_integrity();
        $this->check_mysqli_errors(true);

        /** The result of the query */
        $queryResult = [];
        /** The number of queries found in the `query` */
        $queryCount = (function () {
          $count = substr_count($this->query, ';');
  
          if ($count > 1) {
            return $count;
          }
          else if ($count == 1) {
            return 1;
          }
          else {
            return 1;
          }
        })();
        $queryType = $this->prepared_variables === null
                     ? 'standard'
                     : 'prepared';
                     
        if ($queryType == 'standard') {
          $totalItemCount = (function () {
            if ($this->options->get_result_set_data) {
              $countQueryStr = (function () {
                $queryStr = $this->query;
  
                $queryStr = explode(';', $queryStr);

                foreach ($queryStr as $index => $query) {
                  if (!preg_match('/^((?:SELECT){1}(?:[^;])+(?:;(?: ){0,1}|$){1})+$/i', $query)) {
                    array_splice($queryStr, $index, 1);
                  }
                }

                $queryStr = preg_replace([
                  '/(?:SELECT)(?:.+)(\b(?:FROM|SET)\b)(?!.*\b\1\b)/i',
                  '/(\bWHERE\b)(?!.*\b\1\b) (.+?) (?:GROUP BY|ORDER BY|LIMIT|OFFSET){0,1} (?:.+?)($|;)/i',
                  '/LIMIT {0,1}\d+/',
                  '/OFFSET {0,1}\d+/',
                  '/ ;/'
                ],
                [
                  "SELECT COUNT(*) AS 'count' $1", 
                  "$1 $2$3", 
                  "",
                  "",
                  ";"
                ], 
                $queryStr);
                $queryStr = implode(';', $queryStr);
  
                // Add final delimiter
                if (preg_match('/;([ \r\n]+$)/', $queryStr) === false) {
                  $queryStr .= ';'; 
                }
  
                return $queryStr;
              })();
              $countQueryOptions = [
                'collapse_result'        => true,
                'collapse_row'           => true,
                'allow_multiple_queries' => true
              ];
              $countQuery = new ShiftCodesTKDatabaseQuery($countQueryStr, $countQueryOptions);
              $countQueryResult = $countQuery->query();
  
              return $countQueryResult;
            }
  
            return false;
          })();
          $processResultSet = function ($result_set, $i = 0) use ($queryCount, $totalItemCount) {
            $processedResult = [];
            $resultSetQueryStr = (function () use ($queryCount, $i) {
              if ($queryCount == 1) {
                return $this->query;
              }
              else {
                $matches = [];
  
                preg_match_all('/(?:[^;]+)(?:;|$){0,1}(?: {0,1})/i', $this->query, $matches, PREG_SET_ORDER);
  
                if ($matches) {
                  return $matches[$i][0];
                }
                else {
                  return $this->query;
                }
              }
            })();
            $queryReturnsResults = preg_match('/^(?:SELECT){1}/', $resultSetQueryStr);
            $fieldMetadata = (function () use ($queryReturnsResults, &$result_set) {
              if ($queryReturnsResults && !is_bool($result_set)) {
                $fieldMetadata = [];

                while ($fieldData = $result_set->fetch_field()) {
                  // $fieldName = $fieldData->name;
                  $fieldMetadata[$fieldData->name] = new ShiftCodesTKDatabaseQueryResultFieldMetadata($fieldData);

                  // $fieldMetadata[$fieldName] = $fieldData;
                  // $fieldMetadata[$fieldName]->type_name = ShiftCodesTKDatabase::get_field_type_info($fieldData->type)['name'];
                }

                return $fieldMetadata;
              }

              return null;
            })();
            $resultSetData = (function () use ($queryCount, $totalItemCount, $i, $resultSetQueryStr, $queryReturnsResults) {
              if ($queryReturnsResults && $totalItemCount !== false) {
                $totalResultChunkSize = $queryCount > 1 
                                        ? $totalItemCount[$i] 
                                        : $totalItemCount[0];
                if ($totalResultChunkSize !== false) {
                  return new ShiftCodesTKDatabaseQueryResultSetData($resultSetQueryStr, $this->mysqli->affected_rows, $totalResultChunkSize->result);
                }
              }
              
              return null;
            })();
    
            // `SELECT` Results
            if (!is_bool($result_set)) {
              while ($row = $result_set->fetch_assoc()) {
                if ($fieldMetadata) {
                  foreach ($row as $col => &$val) {
                    $typeInfo = ShiftCodesTKDatabase::get_field_type_info($fieldMetadata[$col]->type);
  
                    if ($typeInfo) {
                      if ($typeInfo['category'] == 'numeric') {
                        $intTypes = [
                          'BIT',
                          'TINYINT',
                          'SMALLINT',
                          'MEDIUMINT',
                          'INT',
                          'BIGINT',
                          'NUMERIC'
                        ];
                        $floatTypes = [
                          'DECIMAL',
                          'FLOAT',
                          'DOUBLE'
                        ];

                        settype($val, array_search($typeInfo['name'], $floatTypes) !== false ? 'float' : 'integer');
                      }
                      else if ($typeInfo['name'] == 'JSON') {
                        $val = json_decode($val, true);
                      }
                    }
                  }
                }

                $processedResult[] = $row;
                // if ($this->options->collapse_row && count($row) == 1) {
                //   $processedResult[] = reset($row);
                // }
                // else {
                // }
              }
    
              $result_set->free_result();
            }
            // `INSERT` Results
            else if ($this->mysqli->insert_id != 0) {
              $processedResult[] = [ 'insert_id' => $this->mysqli->insert_id ];
            }
            // `UPDATE`, `DELETE`, etc... Results
            else if ($this->mysqli->affected_rows > -1) {
              $processedResult[] = [ 'affected_rows' => $this->mysqli->affected_rows ];
            }
            // Bad Result
            else {
              $processedResult = false;
            }
    
            return new ShiftCodesTKDatabaseQueryResult([
              'result'     => $processedResult,
              'field_metadata' => $this->options->get_field_metadata && $queryReturnsResults ? $fieldMetadata : null,
              'result_set' => $resultSetData
            ]);
          };

          // Single Query
          if ($queryCount == 1) {
            $result = $this->mysqli->query($this->query);
    
            $this->check_mysqli_errors(false, function () use (&$result) {
              if (!is_bool($result)) {
                $result->free_result();
              }
            });
  
            $queryResult[] = $processResultSet($result);
          }
          // Multi Query
          else {       
            $this->mysqli->multi_query($this->query);
            $i = -1;
  
            do {
              $i++;
              $result = $this->mysqli->store_result();
  
              $this->check_mysqli_errors(false, function () use (&$result) {
                if (!is_bool($result)) {
                  $result->free_result();
                }
              });
  
              $queryResult[] = $processResultSet($result, $i);
            }
            while ($this->mysqli->more_results() && $this->mysqli->next_result());
          }
        }
        else if ($queryType == 'prepared') {
          /** The results of a prepared query result set */
          $results = [];
          $preparedVars = $this->prepared_variables->variables;

          if (!$preparedVars) {
            throw new Exception('You must add variables with "ShiftCodesTKDatabaseQueryPreparedVariables->change_variables()" before you can execute the query.');
          }

          $preparedStatement = $this->mysqli->prepare($this->query);
          $queryReturnsResults = preg_match('/^(?:SELECT){1}/', $this->query);
          $totalItemCount = (function () use ($queryReturnsResults) {
            if ($this->options->get_result_set_data && $queryReturnsResults) {
              $countQueryStr = (function () {
                $queryStr = $this->query;
  
                $queryStr = explode(';', $queryStr);
                $queryStr = preg_replace([
                  '/(?:SELECT)(?:.+)(\b(?:FROM|SET)\b)(?!.*\b\1\b)/i',
                  '/(\bWHERE\b)(?!.*\b\1\b) (.+?) (?:GROUP BY|ORDER BY|LIMIT|OFFSET){0,1} (?:.+?)($|;)/i',
                  '/LIMIT {0,1}\d+/',
                  '/OFFSET {0,1}\d+/',
                  '/ ;/'
                ],
                [
                  "SELECT COUNT(*) AS 'count' $1", 
                  "$1 $2$3", 
                  "",
                  "",
                  ";"
                ], 
                $queryStr);
                $queryStr = implode(';', $queryStr);
  
                // Add final delimiter
                if (preg_match('/;([ \r\n]+$)/', $queryStr) === false) {
                  $queryStr .= ';'; 
                }
  
                return $queryStr;
              })();
              $countQueryOptions = [
                'collapse_result'        => true,
                'collapse_row'           => true,
                'allow_multiple_queries' => true
              ];
              $countQuery = new ShiftCodesTKDatabaseQuery($countQueryStr, $countQueryOptions, $this->prepared_variables);
              $countQueryResult = $countQuery->query();
  
              return $countQueryResult;
            }

            return false;
          })();

          $this->check_mysqli_errors();

          // Execute Prepared Statements
          for ($i = 0; $i < count($preparedVars); $i++) {
            $setResult = [];
            $vars = array_values($preparedVars[$i]);

            $preparedStatement->bind_param($this->prepared_variables->type_string, ...$vars);
            $preparedStatement->execute();
            $preparedStatement->store_result();

            $this->check_mysqli_errors();

            $fieldMetadata = (function () use ($queryReturnsResults, &$preparedStatement) {
              if ($queryReturnsResults) {
                $metadata = $preparedStatement->result_metadata();
  
                if ($metadata && !is_bool($metadata)) {
                  $fieldMetadata = [];
  
                  while ($fieldData = $metadata->fetch_field()) {
                    $fieldName = $fieldData->name;

                    $fieldMetadata[$fieldName] = $fieldData;
                    $fieldMetadata[$fieldName]->type_name = ShiftCodesTKDatabase::get_field_type_info($fieldData->type)['name'];
                  }
  
                  $metadata->free_result();

                  return $fieldMetadata;
                }
              }

              return null;
            })();
            $resultSetData = (function () use ($totalItemCount, $i, $queryReturnsResults, &$preparedStatement) {
              if ($queryReturnsResults && $totalItemCount !== false) {
                $totalResultChunkSize = count($this->prepared_variables->variables) > 1 
                                        ? $totalItemCount[$i] 
                                        : $totalItemCount[0];

                if ($totalResultChunkSize !== false) {
                  return new ShiftCodesTKDatabaseQueryResultSetData(
                    $this->query, 
                    $preparedStatement->num_rows > 0
                      ? $preparedStatement->num_rows
                      : $preparedStatement->affected_rows, 
                    $totalResultChunkSize->result
                  );
                }
              }
              
              return null;
            })();
            
            // `SELECT` Results
            if ($preparedStatement->num_rows > 0) {
              $results = array_keys($fieldMetadata);
              $preparedStatement->bind_result(...$results);
              
              while ($preparedStatement->fetch()) {
                $row = [];
                
                foreach ($results as $field => &$value) {
                  $row[$field] = $value;

                  if ($fieldMetadata) {
                    $typeInfo = ShiftCodesTKDatabase::get_field_type_info(array_values($fieldMetadata)[$field]->type);
  
                    if ($typeInfo) {
                      if ($typeInfo['category'] == 'numeric') {
                        $floatTypes = [
                          'DECIMAL',
                          'NUMERIC',
                          'FLOAT',
                          'DOUBLE'
                        ];
  
                        settype($value, array_search($typeInfo['name'], $floatTypes) !== false ? 'float' : 'integer');
                      }
                      else if ($typeInfo['name'] == 'JSON') {
                        $value = json_decode($value, true);
                      }
                    }
                  }
                }
                
                $setResult[] = array_combine(array_keys($fieldMetadata), $row);
              }
            }
            // `INSERT` Results
            else if ($preparedStatement->insert_id != 0) {
              $setResult[] = [ 'insert_id' => $preparedStatement->insert_id ];
            }
            // `UPDATE`, `DELETE`, etc... Results
            else if ($preparedStatement->affected_rows > -1) {
              $setResult[] = [ 'affected_rows' => $preparedStatement->affected_rows ];
            }
            // Bad Result
            else {
              $setResult[] = false;
            }
    
            $queryResult[] = new ShiftCodesTKDatabaseQueryResult([
              'result'     => $setResult,
              'field_metadata' => $this->options->get_field_metadata && $queryReturnsResults ? $fieldMetadata : null,
              'result_set' => $resultSetData
            ]);

            $preparedStatement->free_result();
          }
        }

        $this->result = $queryResult;

        return $this->get_result();
      }
      catch (\Throwable $exception) {
        if ($this->options->create_response_object) {
          $this->response->set(500);

          if ($this->options->log_response_issues) {
            $this->response->setError(errorObject('DatabaseQueryError', null, $exception->getMessage()));
          }
        }

        trigger_error("Database Query Failed: {$exception->getMessage()}");
        return false;
      }
    }
    /**
     * Retrieve the result of the query.
     * - You *must* call `query()` before you can use this method.
     * 
     * @return mixed Returns the result of the previous query. 
     * - This value is formatted based on the `collapse_query_result`, `collapse_result`, `collapse_row`, & `collapse_all` options. You can use the `collapse_all` option to collapse all arrays where only one item is returned. 
     * - The return value begins as a `multi-dimensional array`, and is modified accordingly:
     * - - `[ [ [ id => 1 ] ] ]` **<--** The outer-most array holds the *query results*. You can use the `collapse_query_result` option to collapse this array when only one query result is returned.
     * - - `[ [ [ id => 1 ] ]` **<--** The second array holds the *query result*. You can use the `collapse_result` option to collapse this array when only one result is returned.
     * - - `[ [ [ id => 1 ]` **<--** The inner-most array holds the *result date*. You can use the `collapse_row` option to collapse this array when only one row is returned.
     * - If the response data has not been retrieved yet, or if an error occurred while executing the query, returns **null**.
     */
    public function get_result () {
      $result = null;
      
      if ($this->result !== null) {
        // Process Query Results
        foreach ($this->result as $queryIndex => $queryResult) {
          $result[$queryIndex] = clone $queryResult;
          $resultData = &$result[$queryIndex]->result;
  
          // Process Result Sets
          foreach ($resultData as $resultSetIndex => &$resultSet) {
            // Process Rows
            foreach ($resultSet as $field => &$value) {
              $formatParameter = $this->options->format_parameters[$field] ?? false;
              $isDate = validateDate($value, ShiftCodesTKDatabase::DATE_FORMATS);
  
              if ($isDate) {
                $timezone = (function () use ($resultSet, $formatParameter) {
                  $tz = $formatParameter && ($formatParameter['use_timezone'] ?? false)
                        ? $formatParameter['use_timezone']
                        : null;
                        
                  if ($tz) {
                    $timezone = $resultSet[$tz] ?? false;
  
                    if ($timezone) {
                      try {
                        $dtTimezone = new DateTimeZone($timezone);
  
                        if ($dtTimezone) {
                          return $dtTimezone;
                        }
                      }
                      catch (Throwable $exception) {
                        trigger_error("\"{$timezone}\" is not a valid timezone name.", E_USER_WARNING);
                      }
                    }
  
                    trigger_error("\"{$tz}\" is not a valid timezone field.", E_USER_WARNING);
                  }
  
                  return null;
                })();
                $date = new DateTime($value, $timezone);
  
                if ($date) {
                  $value = $date->format('c'); 
                }
              }
              else if ($formatParameter && ($formatParameter['use_timezone'] ?? false)) {
                trigger_error("The \"use_timezone\" option cannot be used with \"{field}\", as it does not have a valid Date-Time value.", E_USER_WARNING);
              }
  
              if ($formatParameter && ($formatParameter['change_type'] ?? false)) {
                $type = $formatParameter['change_type'];
  
                if ($type == 'json_array' || $type == 'json_object') {
                  $value = json_decode($value, $type == 'json_array');
                }
                else {
                  settype($value, $formatParameter['change_type']);
                }
              }
            }
            
            if (($this->options->collapse_all || $this->options->collapse_row) && count($resultSet) == 1) {
              $resultSet = $resultSet[array_key_first($resultSet)];
            }
          }
          
          if ($result[$queryIndex]->field_metadata) {
            foreach ($result[$queryIndex]->field_metadata as $field => &$fieldMetadata) {
              $fieldMetadata = $fieldMetadata->get_metadata($this->options->get_field_metadata === 'ADVANCED');
            }
          }
          if (($this->options->collapse_all || $this->options->collapse_result) && count($resultData) == 1) {
            $resultData = $resultData[array_key_first($resultData)];
          }
          if (($this->options->collapse_all || $this->options->collapse_result_data)) {
            if (!$result[$queryIndex]->field_metadata && !$result[$queryIndex]->result_set) {
              $result[$queryIndex] = $result[$queryIndex]->result;
            }
          }
        }
  
        if (($this->options->collapse_all || $this->options->collapse_query_result) && count($result) == 1) {
          $result = $result[array_key_first($result)];
        }
      }

      return $result;
    }
    /**
     * Retrieve the `ResponseObject` of the query.
     * - The `create_response_object` option must be **true** for this method to work.
     * - You *must* call `query()` before the `payload` can be populated.
     * 
     * @return ResponseObject Returns the `ResponseObject` of the query. 
     * - The response payload is formatted the same way as `get_result()`. 
     * @throws Exception Throws an error if `create_response_object` is **false**.
     */
    public function get_response () {
      $response = false;

      if (!$this->options->create_response_object) {
        throw new Error("Cannot retrieve query ResponseObject: \"create_response_object\" is \"false\".");
      }
      
      $response = clone $this->response;
      $result = $this->get_result();

      if ($result !== null) {
        $response->payload = $result;
      }

      return $response;
    }
  }

  /** Initialization */
  ShiftCodesTKDatabase::get_instance();

  /** Deprecated Functionality */

  /**
   * Represents a connection between PHP and the ShiftCodesTK Database.
   */
  class ShiftCodesTKDatabase_Old {
    /**
     * The connection handle
     */
    public $con;
    public $dateFormats = [];

    /**
     * Trigger a SQL Query Error
     * 
     * @return boolean Returns false after the error has been logged
     */
    private function queryError () {
      trigger_error("SQL Query Error: {$this->con->error}");
      return false;
    }
    /**
     * Perform updates to the returned set of results
     * 
     * @param array $resultSet The array of results
     * @param array $options The array of passed options
     * @return array Returns the updated array
     */
    private function update_result ($resultSet, $options) {
      $processRow = function (&$rowToProcess) use (&$processRow, $options) {
        foreach ($rowToProcess as $field => &$value) {
          if (is_array($value)) {
            $processRow($value);
            continue;
          }

          $isDate = validateDate($value, $this->dateFormats);
          $preserveDate = (!$value || (is_array($options['preserveDate']) && array_search($field, $options['preserveDate']) !== false || $options['preserveDate'] == 'all'));

          if (!$preserveDate && $isDate) {
            $date = new DateTime($value);
            $value = $date->format('c');
          }
        }
      };

      if (!is_array($resultSet)) {
        $result = [ $resultSet ];
      }
      else {
        $result = $resultSet;
      }

      foreach ($result as &$row) {
        if (is_array($row)) {
          $processRow($row);
        }
        else {
          $isDate = validateDate($row, $this->dateFormats);
          $preserveDate = (!$row || $options['preserveDate'] == 'all');

          if (!$preserveDate && $isDate) {
            $date = new DateTime($row);
            $row = $date->format('c');
          }
        }
      }

      if ($options['collapseResult'] & count($result) == 1) {
        $result = $result[0];
      }

      return $result;
    }
    /**
     * Update the options array as needed
     * 
     * @param array $options The provided options array
     * @return array Returns the updated array.
     */
    private function update_options (&$options) {
      $collapses = [
        'collapseResult', 
        'collapseQueryResult', 
        'collapseRow', 
        'collapseAll'
      ];
      $additionalOptions = [
        'allowMultipleQueries',
        'getResultSetData',
        'preserveDate',
        'useTimezone'
      ];

      foreach ($collapses as $collapse) {
        if (isset($options['collapseAll']) && $options['collapseAll']) {
          $options[$collapse] = true;
        }
        else {
          $options[$collapse] = $options[$collapse] ?? false;
        }
      }
      foreach ($additionalOptions as $opt) {
        $options[$opt] = $options[$opt] ?? false;
      }

      return $options;
    }
    private function update_query (&$query, $options) {
      $query = collapseWhitespace($query);

      return $query;
    }

    /**
     * Perform a simple query against the database
     * 
     * @param string $query The SQL Statement to query the database with. 
       * - Note: The query is *not* automatically sanitized and escaped. You must do so manually.
     * @param array $options Additional options for automatically formatting the result
       * 
       * [collapseResult] boolean 
         * If set to true, a single result will automatically be collapsed to just the returned row.
         * - Only applies to SELECT queries
         * - Example: [ [ 'id' => 1 ] ] becomes [ 'id' => 1 ]
       *
       * [collapseRow] boolean 
         * If set to true, a single row result will automatically be collapsed to just the returned value.
         * - Only applies to SELECT queries
         * - Example: [ 'id' => 1 ] becomes 1 
       *
       * [collapseAll] boolean
         * If set to true, single results and single rows will automatically be collapsed.
         * - Only applies to SELECT queries
         * - Shorthand for [ 'collapseResult' => true, 'collapseRow' => true ]
         * - Example: [ [ 'id' => 1 ] ] becomes 1
       *
       * [preserveDate] array|string 
         * An array of field names whose datetime values should not be converted to ISO 8601 format. Alternatively, the keyword "all" will preserve the date of all results in the set.
         * - Note: If [collapseRow] is set to true, only the keyword "all" will have any effect.
       *
     * @return any For SELECT queries, returns the result on success, formatted based on passed options. On error, returns false.
       * For other queries, returns an returns the number of updated rows on success, or false on error.
     */
    public function query ($query, $options = []) {
      $result = [];
      $queryCount = (function () use ($query) {
        $count = substr_count($query, ';');

        if ($count > 1) {
          return $count;
        }
        else if ($count == 1) {
          return 2;
        }
        else {
          return 1;
        }
      })();

      $this->update_options($options);
      $this->update_query($query, $options);

      $totalChunkSize = (function () use ($query, $options, $queryCount) {
        if ($options['getResultSetData']) {
          $countQuery = (function () use ($query, $queryCount) {
            $str = $query;

            $str = explode(';', $str);

            $str = preg_replace([
              '/(?:SELECT|UPDATE|DELETE)(?:.+)(\b(?:FROM|SET)\b)(?!.*\b\1\b)/i',
              '/(\bWHERE\b)(?!.*\b\1\b) (.+?) (?:GROUP BY|ORDER BY|LIMIT|OFFSET){0,1} (?:.+?)($|;)/i',
              '/LIMIT {0,1}\d+/',
              '/OFFSET {0,1}\d+/',
              '/ ;/'
            ],
            [
              "SELECT COUNT(*) $1", 
              "$1 $2$3", 
              "",
              "",
              ";"
            ], 
            $str);

            $str = implode(';', $str);

            if (preg_match('/;([ \r\n]+$)/', $str) === false) {
              $str .= ';'; 
            }

            return $str;
          })();

          $countData = $this->query($countQuery, [ 'collapseAll' => true, 'allowMultipleQueries' => true ]);

          return $countData;
        }
        else {
          return false;
        }
      })();

      $processResultSet = function ($resultSet) use ($query, $options, $queryCount) {
        $processedResult = [];

        // `SELECT` Results
        if (!is_bool($resultSet)) {
          while ($row = $resultSet->fetch_assoc()) {
            if ($options['collapseRow'] && count($row) == 1) {
              $processedResult[] = reset($row);
            }
            else {
              $processedResult[] = $row;
            }
          }
    
          $resultSet->free_result();
        }
        // `INSERT`, `UPDATE`, `DELETE`, etc... Results 
        else {
          if ($this->con->insert_id != 0) {
            $processedResult = $this->con->insert_id;
          }
          else if ($this->con->affected_rows > -1) {
            $processedResult = $this->con->affected_rows;
          }
          else {
            $processedResult = false;
          }
        }

        $processedResult = $this->update_result($processedResult, $options);

        return $processedResult;
      };

      if (!$this->con->errno) {
        // Single Query
        if ($queryCount == 1) {
          $queryResult = $this->con->query($query);

          // On Error
          if ($this->con->errno) {
            $result = $this->queryError();
            $queryResult->free_result();
            return $result;
          }

          $result = $processResultSet($queryResult);
        }
        // Multi Query
        else {
          if ($options['allowMultipleQueries']) {
            if ($this->con->multi_query($query)) {
              do {
                $queryResult = $this->con->store_result();
                
                // On Error
                if ($this->con->errno) {
                  $result[] = $this->queryError();
                  $queryResult->free_result();
                  continue;
                }

                $result[] = $processResultSet($queryResult);
              }
              while ($this->con->more_results() && $this->con->next_result());
            }
          }
          else {
            trigger_error('Multiple Queries are not permitted.', E_USER_WARNING);
            return false;
          }
        }

        if ($options['getResultSetData']) {
          // Update Result
          (function () use (&$result, $query, $totalChunkSize, $queryCount) {
            $getResultArray = function ($resultData, int $totalResultChunkSize) use ($query) {
              $resultArray = [];
              $resultArray['result'] = $resultData;
              $resultArray['result_set'] = [];
              $resultSet = &$resultArray['result_set'];

              $resultSet['max_chunk_size'] = (function () use ($query, $totalResultChunkSize) {
                $max = $totalResultChunkSize;
                $matches = [];
    
                if (preg_match('/(\bLIMIT\b)(?!.*\b\1\b) (\d+)/i', $query, $matches)) {
                  $max = $matches[2];
                }
    
                return (int) $max;
              })();
              $resultSet['current_chunk_size'] = $this->con->affected_rows;
              $resultSet['total_chunk_size'] = $totalResultChunkSize;
              $resultSet['current_chunk'] = (function () use ($query, $resultSet) {
                $chunk = 1;
                $maxChunkSize = $resultSet['max_chunk_size'];
                $matches = [];
    
                if ($maxChunkSize > 0 && preg_match('/(\bOFFSET\b)(?!.*\b\1\b) (\d+)/i', $query, $matches)) {
                  $newChunk = ($matches[2] / $maxChunkSize) + 1;
  
                  if ($newChunk > 0) {
                    $chunk = $newChunk;
                  }
                }
    
                return $chunk;
              })();
              $resultSet['total_chunks'] = (int) ceil($totalResultChunkSize / $resultSet['max_chunk_size']);
              $resultSet['has_previous_chunk'] = $resultSet['current_chunk'] != 1;
              $resultSet['has_next_chunk'] = $resultSet['current_chunk'] != $resultSet['total_chunks'];
              $resultSet['chunk_contents'] = (function () use ($resultSet) {
                $maxChunkSize = $resultSet['max_chunk_size'];
                $currentChunkSize = $resultSet['current_chunk_size'];
                $currentChunk = $resultSet['current_chunk'];
                $items = [];
        
                $lastItem = $maxChunkSize * $currentChunk;
                $firstItem = $lastItem - ($maxChunkSize - 1);
  
                for ($resultIndex = 0; $resultIndex < $currentChunkSize; $resultIndex++) {
                  $items[] = $firstItem + $resultIndex;
                }
  
                return $items;
              })();

              return $resultArray;
            };

            if ($queryCount == 1) {
              $result = $getResultArray($result, $totalChunkSize);
            }
            else if ($result) {
              foreach ($result as $queryIndex => &$queryResult) {
                $queryResult = $getResultArray($queryResult, $totalChunkSize[$queryIndex]);
              }
            }
          })();
        }

        return $result;
      }
    }
    /**
     * Perform prepared queries against the database
     * 
     * @param string $query The Prepared SQL Statement to query the database with. 
     * @param string $types The type string to pass to bind_param
      * - 'i' - integer
      * - 'd' - double
      * - 's' - string
      * - 'b' - blob
     * @param array $params The values to be substituted in. For repeated queries, multiple arrays of values are used.
     * @param array $options Additional options for automatically formatting the result
       *   
       * [collapseResult] boolean 
         * If set to true, a single result will automatically be collapsed to just the returned row.
         * - Only applies to SELECT queries
         * - Example: [ [ [ 'id' => 1 ] ] ] becomes [ [ 'id' => 1 ] ]
       *
       * [collapseQueryResult] boolean
         * If set to true, a single query result will automatically be collapsed to just the returned result set.
         * - Only applies to SELECT queries
         * - Example: [ [ 'id' => 1 ] ] becomes [ 'id' => 1 ]
       *
       * [collapseRow] boolean 
         * If set to true, a single row result will automatically be collapsed to just the returned value.
         * - Only applies to SELECT queries
         * - Example: [ 'id' => 1 ] becomes 1 
       *
       * [collapseAll] boolean
         * If set to true, single results, single query results, and single rows will automatically be collapsed.
         * - Only applies to SELECT queries
         * - Shorthand for [ 'collapseResult' => true, 'collapseQueryResult' => true, 'collapseRow' => true ]
         * - Example: [ [ [ 'id' => 1 ] ] ] becomes 1
       *
       * [preserveDate] array|string 
         * An array of field names whose datetime values should not be converted to ISO 8601 format. Alternatively, the keyword "all" will preserve the date of all results in the set.
         * - Note: If [collapseRow] is set to true, only the keyword "all" will have any effect.
       *
     * @return any For SELECT queries, returns an array of results on success, formatted based on the passed options. On error, returns false.
       * For other queries, returns an array of results for each query. Each query returns the number of updated rows on success, or false on error.
     */
    public function prepared_query ($query, $types, array $params, $options = []) {
      $result = [];
      $queryError = function () {
        trigger_error("SQL Query Error: {$this->con->error}");
        return false;
      };

      $this->update_options($options);
      
      // Add index to params if needed
      if (!is_array(reset($params))) {
        $params = [ $params ];
      }
      
      if (!$this->con->errno) {
        $fields = [];
        $stmt = $this->con->prepare(collapseWhitespace($query));
        
        // On Error
        if ($this->con->error) {
          return $this->queryError();
        }

        for ($i = 0; $i < count($params); $i++) {
          $queryResult = [];
          $param = &$params[$i];

          $stmt->bind_param($types, ...$param);
          $stmt->execute();
          $stmt->store_result();

          // On Error
          if ($this->con->error) {
            return $this->queryError();
          }

          if ($stmt->num_rows > 0) {
            // Create associative array of fields
            if ($i == 0) {
              $meta = $stmt->result_metadata();

              while ($field = $meta->fetch_field()) {
                $fields[] = $field->name;
              }
            }

            $values = $fields;

            $stmt->bind_result(...$values);

            while ($stmt->fetch()) {
              $row = [];

              foreach ($values as $key => $value) {
                $row[$key] = $value;
              }

              if ($options['collapseRow'] && count($row) == 1) {
                $queryResult[] = reset($row);
              }
              else {
                $queryResult[] = array_combine($fields, $row);
              }
            }

            if ($options['collapseQueryResult'] && count($queryResult) == 1) {
              $result[] = reset($queryResult);
            }
            else {
              $result[] = $queryResult;
            }
          }
          else if ($stmt->affected_rows > -1) {
            $result[] = $stmt->affected_rows;
          } 
          else {
            $result[] = false;
          }

          $stmt->reset();
        }

        $stmt->close();
      }

      return $this->update_result($result, $options);
    }

    /**
     * Initialize a connection with the database
     * 
     * @return object Returns the connection handle
     */
    public function __construct () {
      $this->con = new mysqli(...array_values(TK_SECRETS['db']));

      $this->dateFormats['date'] = 'Y-m-d';
      $this->dateFormats['time'] = 'H:i:s';
      $this->dateFormats['dateTime'] = "{$this->dateFormats['date']} {$this->dateFormats['time']}";
      $this->dateFormats['fullDateTime'] = "{$this->dateFormats['dateTime']}.u";

      if ($this->con->connect_errno) {
        trigger_error("MySQL Connection Failed: {$this->con->connect_error}");
        exit;
      }

      // Set Session Timezone to UTC
      $sql = $this->query("SET @@session.time_zone = '+00:00'", [ 'collapseAll' => true ]);

      if ($sql === false) {
        trigger_error("Failed to set MySQL Session Timezone: {$this->con->connect_error}");
        exit;
      }

      return $this->con;
    }
  }
  /**
   * The ShiftCodesTK Database and all associated functionality
   */
  $_mysqli = new ShiftCodesTKDatabase_Old();
?>