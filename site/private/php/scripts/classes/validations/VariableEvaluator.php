<?php
  namespace ShiftCodesTK\Validations;
  use ShiftCodesTK\Strings;

  /** Represents a variable being tested */
  class VariableEvaluator {
    /** @var mixed The variable being evaluated. */
    protected $variable = null;
    /** @var array Rerpresents the *Last Validation Result*.
     * 
     * | Property | Description |
     * | --- | --- |
     * | *result* | A `bool` representing the result of the last validation. **True** designates success, while **false** designates failure. |
     * | *warnings* | An `array` of warnings generated by the last validation. |
     * | *errors* | An `array` of errors generated by the last validation. | 
     * 
     * You can use the `last_result()`, `last_warnings()`, and `last_errors()` to retrieve these values.
     */
    protected $last_result = [
      'result'   => null,
      'warnings' => [],
      'errors'   => []
    ];

    /**
     * @var string The allowed type(s) of the parameter. Multiple types can be separated by a pipe (`|`).
     * - See `VARIABLE_TYPES` for the list of supported types.
     */
    public $type = 'mixed';
    /**
     * @var boolean Indicates if the variable is *required* and cannot be empty. 
     * - Variables marked as `required` will throw an *Error* instead of a *Warning* if a validation fails.
     */
    public $required = false;
    /**
     * @var boolean Indicates if the variable is *readonly* and cannot be modified. 
     */
    public $readonly = false;
    /**
     * @var mixed The default, inherited, or required value of the parameter.
     * - If `required` if **false**, this value is inherited is the variable fails validation.
     * - If `readonly` is **true**, the variable value *must* match this value to be considered valid.
     */
    public $default_value = null;
    /**
     * @var boolean If **true** and `required` is set to **false**, logs a *Warning* if the variable is *empty*.
     */
    public $optional_empty_warning = false;
    /** @var array An `Associative Array` representing the checks to be performed on the variable.
     * - Checks are provided in the following format:
     * > `string` *Check Name* => `array` *Check Arguments*
     * - - *Check Name* refers to the *Validation Check* being performed. In other words, one of the `Validations\check_*` functions.
     * - - - `check_var` is not a valid option because it is always checked.
     * - - - Valid Checks include:
     * - - - - `check_match`
     * - - - - `check_range`
     * - - - - `check_pattern`
     * - - - - `check_date`
     * - - - - `check_url`
     * - - *Check Arguments* is an `array` made up of the *Arguments* of the *Validation Check* being performed.
     * - - - The first argument of each *Validation Check* (`$var`) does not need to be provided.
     */
    public $validations = [];
    
    /**
     * Start a new evaluation on a variable
     * 
     * @param array $configuration An `array` of properties to pass to the `VariableEvaluator`.
     * @param mixed $var The variable being evaluated. Can be omitted to use the evaluator for multiple variables.
     * @return VariableEvaluator Returns the new `VariableEvaluator` on success.
     */
    public function __construct(array $configuration = [], $var = null) {
      // Configuration Validations
      (function () use ($configuration) {
        // Type
        $type = $configuration['type'];

        if (!check_match($type, array_merge(array_keys(VARIABLE_TYPES), array_values(VARIABLE_TYPES)))) {
          throw new \UnexpectedValueException("\"{$type}\" is not a valid Variable Type.", 1);
        }
      })();

      foreach (\get_object_vars($this) as $property => $currentValue) {
        $configValue = $configuration[$property] ?? null;

        if (isset($configValue)) {
          $this->$property = $configValue;
        }
      }

      if (isset($var)) {
        $this->variable = $var;
      }
    }
    /**
     * Validate a parameter against multiple constraints.
     * 
     * @param mixed $var The parameter to check.
     * @param string|false $key An optional key to be output in warnings and errors.
     * @return array Returns the an array with the results of the validation.
     * - `boolean $valid` — Indicates if the parameter is to be considered valid or not.
     * - `mixed|null $parameter` — The validated parameter. This will be **null** if the parameter is invalid.
     * - `array $warnings` — An array of warnings generated while validating the parameter.
     * - `array $errors` — An array of errors generated while validating the parameter.
     */
    function check_variable ($var, $key = null) {
      /** @var mixed The updated parameter. */
      $param = $var;
      // The parameter type as it's being validated.
      $validationType = isset($param) 
                        ? gettype($param) 
                        : (
                          !is_array($this->type) 
                          ? explode('|', $this->type, 1)[0] 
                          : $this->type
                        );

      $validationIssue = function ($validationIssue, $includeProvidedParameter = true, $threshold = null) use (&$param, $validationType, $key, &$result) {
        $providedParameter = $includeProvidedParameter
                             ? $param
                             : NULL;

        $validationMessage = (function () use ($key, $validationIssue, $threshold, $providedParameter, $validationType) {
          $message = $this->customValidationMessages[$validationIssue]
                    ?? VALIDATION_MESSAGES[$validationIssue];

          if (is_array($message)) {
            if ($validationType != 'any') {
              $message = $message[$validationType] ?? "";
            }
            else {
              $message = $message[gettype($providedParameter)] ?? "";
            }
          }

          // Variable replacements
          (function () use ($key, $threshold, &$message) {
            $message = Strings\str_replace($message, '${param}', $key !== false ? $key : 'Parameter');

            if ($threshold !== null) {
              $plural = checkPlural($threshold);

              $message = Strings\str_replace($message, [ '${threshold}', '${plural}' ], [ $threshold, $plural ]);
            }
          })();

          return $message;
        })();

        if (!$this->required) {
          $this->result['warnings'][] = errorObject($validationIssue, $key, $validationMessage, $providedParameter, $this->default_value);

          if ($this->default_value !== null) {
            $param = $this->default_value;
          }
        }
        else {
          $this->result['valid'] = false;
          $param = null;
          $this->result['errors'][] = errorObject($validationIssue, $key, $validationMessage, $providedParameter);
        }
      };

      if (check_isPresent($param)) {
        $type = (function () use (&$param) {
          if (array_search($this->type, [ 'mixed', 'any' ]) === false) {
            $typeChecks = array_merge(
              array_fill_keys([ 'bool', 'boolean' ], function () use ($param) { 
                return is_bool($param); 
              }),
              array_fill_keys([ 'int', 'integer' ], function () use ($param) { 
                return is_int($param) || (is_numeric($param) && !Strings\substr_check($param, '.')); 
              }),
              array_fill_keys([ 'float', 'double' ], function () use ($param) { 
                return is_float($param) || (is_numeric($param) && Strings\substr_check($param, '.')); 
              }),
              array_fill_keys([ 'function', 'callable' ], function () use ($param) { 
                return is_callable($param);
              }),
              array_fill_keys([ 'null', 'void' ], function () use ($param) { 
                return is_null($param);
              }),
              [
                'string' => function () use ($param) { 
                  return is_string($param);
                },
                'array' => function () use ($param) { 
                  return is_array($param);
                },
                'object' => function () use ($param) { 
                  return is_object($param);
                },
                'iterable' => function () use ($param) { 
                  return is_iterable($param);
                },
                'resource' => function () use ($param) { 
                  return is_resource($param);
                },
              ]
            );
            $validTypes = explode('|', $this->type);
    
            foreach ($validTypes as $type) {
              if (isset($typeChecks[$type]) && $typeChecks[$type]()) {
                if ($type == 'boolean') {
                  if ($param == 'true') {
                    $param = true;
                  }
                  else if ($param == 'false') {
                    $param = false;
                  }
                }
                else if ($type == 'integer') {
                  $param = (int) $param;
                }
                else if ($type == 'float') {
                  $param = (float) $param;
                }

                return $type;
              }
            }

            return false;
          }
          else {
            return gettype($param);
          }

        })();

        if ($type !== false) {
          $validationType = $type;

          // Check Match
          (function () use ($param, $validationIssue) {
            $match = $this->validations['match'] ?? false;

            if ($param !== null && $match) {
              $matchResult = false;

              if (is_array_associative($match)) {
                $matchResult = check_match($param, $match['matches'], $match['properties']);
              }
              else {
                $matchResult = check_match($param, $match);
              }

              if (!$matchResult) {
                $validationIssue('valueMismatch');
              }
            }
          })();
          // Check Range
          (function () use ($param, $validationIssue, $type) {
            $range = $this->validations['range'] ?? false;
    
            if ($param !== null && $range) {
              foreach ($range as $rangeType => $threshold) {
                $rangeCategory = (function () use ($type) {
                  if ($type == 'string' || $type == 'hash' || $type == 'url') {
                    return "string";
                  }
                  else if ($type == 'int' || $type == 'float') {
                    return "number";
                  }
                  else if ($type == 'array') {
                    return "array";
                  }
                  else if ($type == 'date') {
                    return "date";
                  }
                  else {
                    return false;
                  }
                })();
                
                if ($rangeCategory && !check_range($param, $rangeCategory, [ $rangeType => $threshold ])) {
                  $issues = [
                    'min' => 'rangeUnderflow',
                    'is'  => 'rangeMismatch',
                    'max' => 'rangeOverflow'
                  ];

                  $validationIssue($issues[$rangeType], $param, $threshold);
                }
              }
            }
          })();
          // Check Pattern
          (function () use ($param, $validationIssue, $type) {
            $pattern = $this->validations['pattern'] ?? false;
    
            if ($param !== null && $pattern) {
              if (!check_pattern($param, $pattern)) {
                $validationIssue('patternMismatch');
              }
            }
          })();
        }
        // Invalid Type
        else {
          $validationIssue('typeMismatch');
        }
      }
      else {
        if ($this->required || $this->optional_empty_warning) {
          $validationIssue('valueMissing', false);
        }
        else if ($this->default_value !== null) {
          $param = $this->default_value;
        }
      }

      return $result;
    }
  };
?>